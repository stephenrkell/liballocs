#!/bin/bash

# Build a list of allocation sites using the power of objdump.

# some stock definitions
# FIXME: this doesn't escape some metacharacters, notably '[' and ']',
# -- including the latter seemed to mess up the sed expression
# but I could do it using alternation and bare characters, i.e. \|\[\|\]
escape_shell () {
     sed 's/[\$()"'"'"'{}\*?]/\\&/g'
}

escape_regexp () {
    # filter which reads a string on input, and yields a plain grep-style regexp
    # which matches the string literally, by escaping the metacharacters
    sed -r 's/(\*|\.|\[|\^|\$|\[|\]|\\)/\\\1/g'
}

escape_eregexp () {
    # filter which reads a string on input, and yields a plain grep-style regexp
    # which matches the string literally, by escaping the metacharacters
    sed -r 's/(\*|\.|\[|\^|\$|\[|\]|\||\{|\}|\?|\+|\(|\)|\\)/\\\1/g'
}

escape_regexp_awk_lit () {
    echo -n '/'
    sed -r 's#(/|\*|\.|\[|\^|\$|\[|\]|\||\{|\}|\?|\+|\(|\)|\\)#\\\1#g' | tr -d '\n'
    echo -n '/'
}

escapefn_shell () {
    echo "$1" | escape_shell
}
escapefn_regexp () {
    echo "$1" | escape_regexp
}
escapefn_eregexp () {
    echo "$1" | escape_eregexp
}
escapefn_regexp_awk_lit () {
    echo "$1" | escape_regexp_awk_lit
}

make_match_any_line_regexp () {
    # makes a giant regexp which matches any of a set of lines, read from stdin
	# If we don't read any lines from stdin, we return a regexp that doesn't match
	# anything! (At least I hope that's what $^ does.)lank lines.
    escape_regexp | sed 's/\(.*\)/^\\(\1\\)$/' | tr '\n' '\f' | \
    	sed 's/\f$/\n/' | sed 's/\f/\\|/g' |  sed 's/^$/\$\^/'
}

make_match_any_line_floating_regexp () {
    # makes a giant regexp which matches any of a set of lines, read from stdin
	# If we don't read any lines from stdin, we return a regexp that matches only
	# blank lines. Ideally we would return a regexp which doesn't match anything,
	# but it turns out that there is no such grep regexp (I think!) and the
	# alternative suffices for our purposes (below)
    escape_regexp | sed 's/\(.*\)/\\(\1\\)/' | tr '\n' '\f' | \
    	sed 's/\f$/\n/' | sed 's/\f/\\|/g' |  sed 's/^$/\$\^/'
}

make_match_any_line_floating_eregexp () {
	# as above, but makes an eregexp
    escape_eregexp | sed 's/\(.*\)/(\1)/' | tr '\n' '\f' | \
    	sed 's/\f$/\n/' | sed 's/\f/|/g' |  sed 's/^$/\$\^/'
}

line_regexp='^([0-9a-f]*) <([^>]*)>'
alloc_descriptors="${LIBALLOCS_ALLOC_FNS} malloc(Z)p calloc(zZ)p realloc(pZ)p memalign(zZ)p alloca(Z)p"
suballoc_descriptors="${LIBALLOCS_SUBALLOC_FNS:-}"
allocsz_descriptors="${LIBALLOCS_ALLOCSZ_FNS:-}"
all_alloc_descriptors="${alloc_descriptors}${suballoc_descriptors:+ ${suballoc_descriptors}}${allocsz_descriptors:+ ${allocsz_descriptors}}"
echo "all_alloc_descriptors is: $all_alloc_descriptors" 1>&2
# Treat callq of monalloca labels as a possible alloc site, as that's what 
# our alloca instrumentation inserts.
meta_instr_regexp="${line_regexp}.*((call|jmp).*(<($( 
    echo -ne 'malloc\ncalloc\nrealloc\nmemalign\nposix_memalign\nvalloc\n__monalloca_' | \
    make_match_any_line_floating_eregexp )|$( 
    echo -n "${all_alloc_descriptors}" | \
        sed -r 's/([a-zA-Z0-9_]+)\([^\)]*\)[a-zA-Z]?( +|$)/\1\n__wrap_\1\n/g' | \
    make_match_any_line_floating_eregexp ))|.*\*)|.* 00 00 00 00.*callq)"
# HACK: if liballocs_alloc_fns is unset, use "malloc" a second time
# (leaving this out will make the regexp end "|)" so match all calls)

echo "meta_instr_regexp is: $meta_instr_regexp" 1>&2

. "$(dirname "$0")"/objdumpmeta

format_output () {
    while read return_addr_sym return_addr return_addr_offset address filename line_number line_number_end token source_oneline; do
        case "$outputstyle" in
            (tab)
                echo "${return_addr_sym}"$'\t'"${return_addr}"$'\t'"${filename}"$'\t'"${line_number}"$'\t'"${line_number_end}"$'\t'"${token}"$'\t'"${source_oneline}"
                ;;
            (punc)
                echo "<${return_addr_sym}+${return_addr_offset}> @${filename}:${line_number}"$'\t'"${token}"
                ;;
            (*)
                echo "<${return_addr_sym}+${return_addr_offset}> @${filename}:${line_number}"$'\t'"${token}"
                ;;
        esac
    done
}

output_lines="$( generate_output_lines )"

echo "$output_lines" | format_output
